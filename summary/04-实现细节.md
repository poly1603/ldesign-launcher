# Vite Launcher - 实现细节

## 核心实现

### 1. 项目类型检测算法

**多维度检测策略**：
```typescript
class ProjectDetector {
  async detectProjectType(projectPath: string): Promise<DetectionResult> {
    const signals: DetectionSignal[] = []
    
    // 1. 文件系统检测
    signals.push(...await this.detectByFiles(projectPath))
    
    // 2. package.json 依赖检测
    signals.push(...await this.detectByDependencies(projectPath))
    
    // 3. 配置文件检测
    signals.push(...await this.detectByConfigFiles(projectPath))
    
    // 4. 源码内容检测
    signals.push(...await this.detectBySourceCode(projectPath))
    
    // 5. 综合评分和决策
    return this.calculateFinalResult(signals)
  }
}
```

**检测信号权重系统**：
```typescript
const DETECTION_WEIGHTS = {
  PACKAGE_DEPENDENCY: 0.8,      // package.json 依赖
  CONFIG_FILE: 0.7,             // 配置文件存在
  SOURCE_CODE: 0.6,             // 源码特征
  FILE_STRUCTURE: 0.5,          // 文件结构
  NAMING_CONVENTION: 0.3,       // 命名约定
}
```

### 2. 配置生成机制

**分层配置合并**：
```typescript
class ConfigManager {
  async generateViteConfig(
    projectPath: string,
    projectType: ProjectType,
    mode: 'development' | 'production',
    userOptions: any = {}
  ): Promise<ViteConfig> {
    // 1. 基础配置
    const baseConfig = this.getBaseConfig(mode)
    
    // 2. 框架特定配置
    const frameworkConfig = await this.getFrameworkConfig(projectType)
    
    // 3. 插件配置
    const pluginConfig = await this.getPluginConfig(projectType, mode)
    
    // 4. 用户自定义配置
    const userConfig = await this.loadUserConfig(projectPath)
    
    // 5. 智能合并
    return this.mergeConfigs([
      baseConfig,
      frameworkConfig,
      pluginConfig,
      userConfig,
      userOptions
    ])
  }
}
```

**配置预设系统**：
```typescript
const CONFIG_PRESETS = {
  vue3: {
    plugins: ['@vitejs/plugin-vue'],
    resolve: {
      alias: { '@': path.resolve('src') }
    },
    css: {
      preprocessorOptions: {
        scss: { additionalData: '@import "@/styles/variables.scss";' }
      }
    }
  },
  react: {
    plugins: ['@vitejs/plugin-react'],
    esbuild: {
      jsxInject: "import React from 'react'"
    }
  }
}
```

### 3. 插件管理实现

**动态插件加载**：
```typescript
class PluginManager {
  async getRequiredPlugins(projectType: ProjectType): Promise<VitePlugin[]> {
    const plugins: VitePlugin[] = []
    
    // 1. 框架核心插件
    const corePlugin = await this.loadCorePlugin(projectType)
    if (corePlugin) plugins.push(corePlugin)
    
    // 2. TypeScript 支持
    if (await this.hasTypeScript(projectPath)) {
      plugins.push(await this.loadTypeScriptPlugin())
    }
    
    // 3. CSS 预处理器
    const cssPreprocessor = await this.detectCSSPreprocessor(projectPath)
    if (cssPreprocessor) {
      plugins.push(await this.loadCSSPlugin(cssPreprocessor))
    }
    
    // 4. 开发工具插件
    if (mode === 'development') {
      plugins.push(...await this.loadDevPlugins())
    }
    
    return plugins
  }
}
```

### 4. 模板引擎实现

**模板文件处理**：
```typescript
class TemplateEngine {
  async generateProjectFiles(
    targetPath: string,
    projectType: ProjectType,
    templateData: TemplateData
  ): Promise<void> {
    const templatePath = this.getTemplatePath(projectType)
    const files = await this.scanTemplateFiles(templatePath)
    
    for (const file of files) {
      const content = await this.processTemplate(file, templateData)
      const targetFile = this.resolveTargetPath(file, targetPath)
      await this.writeFile(targetFile, content)
    }
  }
  
  private async processTemplate(
    templateFile: string,
    data: TemplateData
  ): Promise<string> {
    let content = await fs.readFile(templateFile, 'utf-8')
    
    // 1. 变量替换
    content = this.replaceVariables(content, data)
    
    // 2. 条件块处理
    content = this.processConditionals(content, data)
    
    // 3. 循环块处理
    content = this.processLoops(content, data)
    
    return content
  }
}
```

### 5. 错误处理机制

**分层错误处理**：
```typescript
class ErrorHandler {
  static createError(code: ErrorCode, message: string, context?: any): LauncherError {
    const error = new LauncherError(message)
    error.code = code
    error.context = context
    error.suggestion = this.getSuggestion(code)
    error.docUrl = this.getDocumentationUrl(code)
    return error
  }
  
  handleError(error: Error, operation: string): LauncherError {
    // 1. 错误分类
    const errorType = this.classifyError(error)
    
    // 2. 上下文增强
    const enhancedError = this.enhanceError(error, operation)
    
    // 3. 用户友好化
    const userFriendlyError = this.makeUserFriendly(enhancedError)
    
    // 4. 日志记录
    this.logError(userFriendlyError)
    
    return userFriendlyError
  }
}
```

## 关键算法

### 1. 依赖解析算法

```typescript
async function resolveDependencies(
  projectType: ProjectType,
  features: string[]
): Promise<DependencyMap> {
  const dependencies: DependencyMap = {
    dependencies: {},
    devDependencies: {}
  }
  
  // 1. 基础框架依赖
  const frameworkDeps = FRAMEWORK_DEPENDENCIES[projectType]
  Object.assign(dependencies.dependencies, frameworkDeps)
  
  // 2. 功能特性依赖
  for (const feature of features) {
    const featureDeps = FEATURE_DEPENDENCIES[feature]
    if (featureDeps) {
      Object.assign(dependencies.dependencies, featureDeps.dependencies)
      Object.assign(dependencies.devDependencies, featureDeps.devDependencies)
    }
  }
  
  // 3. 版本冲突解决
  return this.resolveVersionConflicts(dependencies)
}
```

### 2. 配置合并算法

```typescript
function mergeConfigs(configs: ViteConfig[]): ViteConfig {
  return configs.reduce((merged, config) => {
    return {
      // 简单属性覆盖
      ...merged,
      ...config,
      
      // 数组属性合并
      plugins: [...(merged.plugins || []), ...(config.plugins || [])],
      
      // 对象属性深度合并
      resolve: {
        ...merged.resolve,
        ...config.resolve,
        alias: {
          ...merged.resolve?.alias,
          ...config.resolve?.alias
        }
      },
      
      // 特殊处理
      css: this.mergeCSSConfig(merged.css, config.css)
    }
  }, {})
}
```

### 3. 文件监听优化

```typescript
class FileWatcher {
  private watchCache = new Map<string, fs.FSWatcher>()
  
  watch(path: string, callback: (event: string, filename: string) => void): void {
    if (this.watchCache.has(path)) {
      return // 避免重复监听
    }
    
    const watcher = fs.watch(path, { recursive: true }, (event, filename) => {
      // 防抖处理
      this.debounce(`${path}:${filename}`, () => {
        callback(event, filename)
      }, 100)
    })
    
    this.watchCache.set(path, watcher)
  }
  
  private debounce(key: string, fn: Function, delay: number): void {
    if (this.debounceTimers.has(key)) {
      clearTimeout(this.debounceTimers.get(key))
    }
    
    this.debounceTimers.set(key, setTimeout(() => {
      fn()
      this.debounceTimers.delete(key)
    }, delay))
  }
}
```

## 性能优化实现

### 1. 缓存机制

```typescript
class CacheManager {
  private memoryCache = new Map<string, any>()
  private diskCache = new Map<string, string>()
  
  async get<T>(key: string, factory: () => Promise<T>): Promise<T> {
    // 1. 内存缓存检查
    if (this.memoryCache.has(key)) {
      return this.memoryCache.get(key)
    }
    
    // 2. 磁盘缓存检查
    const diskValue = await this.getDiskCache(key)
    if (diskValue) {
      const parsed = JSON.parse(diskValue)
      this.memoryCache.set(key, parsed)
      return parsed
    }
    
    // 3. 生成新值
    const value = await factory()
    
    // 4. 缓存存储
    this.memoryCache.set(key, value)
    await this.setDiskCache(key, JSON.stringify(value))
    
    return value
  }
}
```

### 2. 并行处理

```typescript
async function parallelInstall(dependencies: string[]): Promise<void> {
  const chunks = this.chunkArray(dependencies, 5) // 每次并行安装5个
  
  for (const chunk of chunks) {
    await Promise.all(
      chunk.map(dep => this.installSingleDependency(dep))
    )
  }
}
```

### 3. 内存管理

```typescript
class MemoryManager {
  private static readonly MAX_CACHE_SIZE = 100
  private static readonly CLEANUP_THRESHOLD = 0.8
  
  checkMemoryUsage(): void {
    const usage = process.memoryUsage()
    const heapUsedMB = usage.heapUsed / 1024 / 1024
    
    if (heapUsedMB > this.MAX_MEMORY_MB * this.CLEANUP_THRESHOLD) {
      this.performCleanup()
    }
  }
  
  private performCleanup(): void {
    // 清理缓存
    this.clearOldCacheEntries()
    
    // 强制垃圾回收
    if (global.gc) {
      global.gc()
    }
  }
}
```

## 安全实现

### 1. 路径安全

```typescript
function sanitizePath(inputPath: string, basePath: string): string {
  const resolved = path.resolve(basePath, inputPath)
  
  // 防止路径遍历
  if (!resolved.startsWith(path.resolve(basePath))) {
    throw new Error('Path traversal detected')
  }
  
  return resolved
}
```

### 2. 输入验证

```typescript
const VALIDATION_SCHEMAS = {
  projectName: /^[a-zA-Z0-9-_]+$/,
  projectPath: /^[^<>:"|?*]+$/,
  port: (port: number) => port >= 1024 && port <= 65535
}

function validateInput(type: string, value: any): boolean {
  const validator = VALIDATION_SCHEMAS[type]
  
  if (typeof validator === 'function') {
    return validator(value)
  }
  
  if (validator instanceof RegExp) {
    return validator.test(value)
  }
  
  return false
}
```

### 3. 依赖安全

```typescript
async function validateDependency(name: string, version: string): Promise<boolean> {
  // 1. 检查包名合法性
  if (!this.isValidPackageName(name)) {
    return false
  }
  
  // 2. 检查版本格式
  if (!semver.valid(version)) {
    return false
  }
  
  // 3. 安全漏洞检查
  const vulnerabilities = await this.checkVulnerabilities(name, version)
  if (vulnerabilities.length > 0) {
    this.logger.warn(`Package ${name}@${version} has known vulnerabilities`)
  }
  
  return true
}
```
